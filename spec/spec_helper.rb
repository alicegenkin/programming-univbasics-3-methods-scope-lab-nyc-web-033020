require 'bundler'
Bundler.require
require 'yaml'
CREATED_FILES = Dir.glob(File.join(File.dirname(__FILE__), '..', 'lib', '*.rb'))
CREATED_FILES.each{ |f| require f }

# This file was generated by the `rspec --init` command. Conventionally, all
# specs live under a `spec` directory, which RSpec adds to the `$LOAD_PATH`.
# The generated `.rspec` file contains `--require spec_helper` which will cause
# this file to always be loaded, without a need to explicitly require it in any
# files.
#
# Given that it is always loaded, you are encouraged to keep this file as
# light-weight as possible. Requiring heavyweight dependencies from this file
# will add to the boot time of your test suite on EVERY test run, even for an
# individual file that may not need all of that loaded. Instead, consider making
# a separate helper file that requires the additional dependencies and performs
# the additional setup, and require it from the spec files that actually need
# it.
#
# See http://rubydoc.info/gems/rspec-core/RSpec/Core/Configuration
RSpec.configure do |config|
  # rspec-expectations config goes here. You can use an alternate
  # assertion/expectation library such as wrong or the stdlib/minitest
  # assertions if you prefer.
  config.expect_with :rspec do |expectations|
    # This option will default to `true` in RSpec 4. It makes the `description`
    # and `failure_message` of custom matchers include text for helper methods
    # defined using `chain`, e.g.:
    #     be_bigger_than(2).and_smaller_than(4).description
    #     # => "be bigger than 2 and smaller than 4"
    # ...rather than:
    #     # => "be bigger than 2"
    expectations.include_chain_clauses_in_custom_matcher_descriptions = true
  end

  # rspec-mocks config goes here. You can use an alternate test double
  # library (such as bogus or mocha) by changing the `mock_with` option here.
  config.mock_with :rspec do |mocks|
    # Prevents you from mocking or stubbing a method that does not exist on
    # a real object. This is generally recommended, and will default to
    # `true` in RSpec 4.
    mocks.verify_partial_doubles = true
  end

  config.shared_context_metadata_behavior = :apply_to_host_groups
end

# To parse and test an HTML file, add 'nokogiri' to Gemfile and uncomment these methods
# def html_file_contents
#   File.read('./index.html')
# end
#
# def parsed_html
#   Nokogiri::HTML(html_file_contents) do |config|
#     config.strict.dtdload.dtdvalid.noblanks
#   end
# end

# To parse and test a CSS file, add 'css_parser' to Gemfile and uncomment this method
# def parsed_css
#   parser = CssParser::Parser.new
#   parser.load_uri!('./style.css')
#   parser
# end

```

Note that the method is trying to `puts` out a variable called `phrase`.

If we run the test for this method only by typing `rspec spec/catch_phrases_spec.rb`
into your terminal in the directory of this lab. You should see the following
error:

```ruby
NameError:
  undefined local variable or method `phrase' for #<RSpec::ExampleGroups::CatchPhrasesRb:0x007fa5eb399b88>
```

This error is occurring because the code inside the `mario` method is trying to
use the `phrase` variable **but** it's not present inside the _scope_ of the
`mario` method. **It is out of scope.**

If we look at the test for this method in `spec/catch_phrase_spec.rb` we can see
that it expects "It's-a me, Mario!" to be printed out.

```ruby
describe "mario" do
  it "puts out 'It's-a me, Mario!'" do
    phrase = "It's-a me, Mario!"
    expect{mario}.to output("It's-a me, Mario!\n").to_stdout
  end
end
```

We need to define the variable `phrase` in our `mario` method. When `phrase` is
called, the output should be "It's-a me, Mario!"

Once `phrase` is defined in the method, the first test should pass. Let's move
on to the next method!

In `lib/catch_phrases.rb`, take a look at the following method:

```ruby
def toadstool
  puts status
end
```

Notice that the body of this method is calling a variable that is set in the
`mario` method. When we run the tests, we are getting a `NameError` because
`status` is `undefined`.

Wait a minute, you might be wondering. Didn't we define `status` inside the
`mario` method? We did, but variables defined inside a method are only
accessible to _that_ method. They are not available outside of _that_ method in any
other context.

Make sure that the `status` variable is in the correct context to be used by the
`toadstool` method.

Now that we've walked through a couple of methods, let's define two new methods
from scratch!

## Define a Method That Outputs a Popular Catch Phrase

Now that our first two tests should be passing, let's try writing a method from
scratch on our own. In `lib/catch_phrases.rb`, define the method `link` that
will output the phrase "It's Dangerous To Go Alone! Take This."

## Define a Method That Calls The Other Methods

For our final method, we'll want to define the method `all_phrases`. This method
does not need to take any parameters, but should call the `mario`, `toadstool`,
and `link` phrases.

For this method, take a look at our test `rspec spec/catch_phrases_spec.rb`
to see the exact expectation:

```ruby
describe "all_phrases" do
  it "takes in an argument and puts out the catch phrase" do
    expect{all_phrases}.to output(/It's-a me, Mario!\n/).to_stdout
    expect{all_phrases}.to output(/Thank You Mario! But Our Princess Is In Another Castle!\n/).to_stdout
    expect{all_phrases}.to output(/It's Dangerous To Go Alone! Take This.\n/).to_stdout
  end
end
```

Now, you could copy and paste the messages from the previous methods, but
calling the other methods directly is much easier!

Now run your tests again. If all methods have been written correctly, you should
see four tests passing!

## Conclusion

We've discussed building methods and recognizing how scope works within the
context of each method. With these concepts put together, we can see how it
functions in practice. As we discuss scope further, we'll understand more about
how to access variables in different scopes.



def mario
  phrase = 'It's-a me, Mario!'
  puts phraselearn
end

def toadstool
  status = 'Thank You Mario! But Our Princess Is In Another Castle!'
  puts status
end

def link
  status = 'It's dangerous to go alone!'
  puts status
end
